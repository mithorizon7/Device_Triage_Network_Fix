You’re building a **password “time-to-crack” estimator** that makes one idea visceral:

> **Brute force is math.** If an attacker has to try every possible string, the time grows **exponentially** with password length.

Below is a clean way to design it so it’s (a) internally consistent, (b) easy to explain in your learning module, and (c) easy for a developer to implement without accidentally making misleading assumptions.

---

## What the tool should do (conceptually)

### 1) Frame the scenario (so learners don’t misinterpret it)

There are *two very different* “brute force” contexts:

* **Online guessing** (attacking a live login form): usually **rate-limited / lockouts / bot detection**, so guesses-per-second can be tiny.
* **Offline guessing** (attacker stole a password database of *hashes*): attacker can try guesses extremely fast on GPUs.

Your article’s GPU framing strongly implies **offline brute force** (GPU cracking makes sense when you have hashes). This matches how the Verizon DBIR describes “Basic Web Application Attacks”: “Use of stolen credentials (77%)” and “Brute force …” as top actions in that pattern. ([Verizon][1])

So: **make your default mode “Offline brute force (hash stolen)”** and clearly label it.

### 2) Convert the password into a search space

For brute force, the core quantity is:

* **L** = password length (characters)
* **A** = size of the attacker’s assumed alphabet (character set)
* **Keyspace** = **A^L** possible passwords

A simple, teachable approximation (and consistent with how password tables are presented) is:

* If password contains lowercase → add 26
* If uppercase → add 26
* If digits → add 10
* If symbols → add ~33 (to reach ~95 printable ASCII total)

That yields **A ≈ 26, 52, 62, or 95** depending on what’s present—matching the “26 vs ~95” story your article tells.

> Important honesty note: this assumes the attacker knows the password is drawn from exactly those categories. Real attackers often try smarter orders (dictionary/patterns first), which is why you should display a warning: “**This estimate assumes a random password**; human-made passwords crack much faster.”

### 3) Choose a “typical attacker speed” (guesses/sec) and stick to it

You can’t get meaningful “time to crack” without an assumed **guess rate**.

A defensible, up-to-date approach is to ground your defaults in publicly cited benchmarking culture (Hashcat + consumer GPUs), similar to what Hive Systems does in their password tables (they explicitly discuss their assumptions and hardware baselines). ([Hive Systems][2])

**Two practical presets (recommended):**

**Preset A — “Worst-case for defenders” (fast hashes):**
Use a rate that reflects *very fast hash types* (or weak storage). Example: RTX 4090-class cracking can hit around **300 GH/s for NTLM** per widely cited benchmark reporting. ([Tom's Hardware][3])
This preset makes short passwords look “instant,” which aligns with the intuition you’re trying to teach.

**Preset B — “Modern web app hashing” (bcrypt):**
bcrypt is intentionally slow. Hashcat community benchmarks cited in the Hashcat forum put **RTX 5090 at ~250–300 kH/s** and **RTX 4090 ~184 kH/s** *at work factor 5 (32 rounds)*, and explain that moving from work factor 5 → 10 makes it ~32× slower. ([hashcat.net][4])
Hive also discusses moving their table assumptions to bcrypt and using consumer GPU stacks. ([Hive Systems][2])

**Why presets beat “one magic number”:** your own examples mix times that can’t all come from the same rate. A single consistent calculator will otherwise “contradict” parts of your narrative. Presets let you keep the message *and* keep the math honest.

### 4) Convert keyspace into time

If guesses are uniformly random over the keyspace:

* **Worst case** tries ≈ A^L
* **Expected / average case** tries ≈ (A^L) / 2
* **Median** ≈ (A^L) * ln(2) (optional)

Then:

* `seconds_avg = (A^L) / (2 * guesses_per_second)`
* `seconds_worst = (A^L) / guesses_per_second`

### 5) Handle huge numbers safely (don’t overflow)

For realistic lengths (12–20+), **A^L is enormous**. Don’t compute it with normal integers/floats.

Use a **log-space** approach for display:

* `log10_keyspace = L * log10(A)`
* `log10_seconds_avg = log10_keyspace - log10(guesses_per_second) - log10(2)`
* Convert `log10_seconds` into friendly units (seconds/minutes/hours/days/years) without ever materializing the huge number.

This also makes the UI snappy.

### 6) UX requirements I’d treat as “must-haves”

* **Compute locally in the browser** (do not send the password to your server; don’t log it). Add: “Don’t enter a real password.”
* Show:

  * detected length L
  * detected character categories and inferred A
  * assumed attacker preset (with a small “what this means” tooltip)
  * average + worst-case time
  * a one-liner explaining the exponential scaling (“each added character multiplies time by A”)
* Add a warning banner:

  * “If your password contains dictionary words/patterns, real cracking can be much faster than this brute-force estimate.”

---

## Pseudocode for your developer

### Configuration (constants + presets)

```pseudo
CHARSET_SIZES = {
  LOWER: 26,
  UPPER: 26,
  DIGIT: 10,
  SYMBOL: 33   // chosen so LOWER+UPPER+DIGIT+SYMBOL ≈ 95
}

ATTACK_PRESETS = {
  // Preset A: fast-hash / worst-case for defenders (illustrative)
  "OFFLINE_FAST_HASH_1xGPU": {
    label: "Offline brute force (fast hash, 1× high-end GPU)",
    guesses_per_second: 3.0e11,     // ~300 GH/s NTLM-class (order-of-mag)
    notes: "Represents very fast cracking when hashes are fast/weak."
  },

  // Preset B: bcrypt (work factor aware)
  "OFFLINE_BCRYPT_WF10_1xRTX5090": {
    label: "Offline brute force (bcrypt WF10, 1× RTX 5090)",
    // Start from WF5 benchmark ~300 kH/s and divide by 32 to estimate WF10
    guesses_per_second: (3.0e5 / 32),   // ≈ 9375 H/s
    notes: "bcrypt is designed to be slow; WF10 is far slower than WF5."
  }
}

DEFAULT_PRESET_KEY = "OFFLINE_FAST_HASH_1xGPU"
```

### Password analysis

```pseudo
function analyze_password(pw_string):
  // IMPORTANT: treat length as Unicode code points if you accept Unicode input.
  // For a training widget, you may restrict to printable ASCII to avoid edge cases.
  L = length(pw_string)

  has_lower = false
  has_upper = false
  has_digit = false
  has_symbol = false

  for each char c in pw_string:
    if 'a' <= c <= 'z': has_lower = true
    else if 'A' <= c <= 'Z': has_upper = true
    else if '0' <= c <= '9': has_digit = true
    else: has_symbol = true   // punctuation, space, unicode, etc.

  // infer alphabet size A
  A = 0
  if has_lower: A += 26
  if has_upper: A += 26
  if has_digit: A += 10
  if has_symbol: A += 33

  // Edge case: empty password or A == 0
  if L == 0 or A == 0:
    return { L, A, has_lower, has_upper, has_digit, has_symbol, valid: false }

  return { L, A, has_lower, has_upper, has_digit, has_symbol, valid: true }
```

### Core math in log-space (preferred)

```pseudo
function estimate_crack_time_log10(L, A, guesses_per_second):
  // log10(A^L) = L * log10(A)
  log10_keyspace = L * log10(A)

  // Average case assumes half the space on average
  log10_seconds_avg   = log10_keyspace - log10(guesses_per_second) - log10(2)
  log10_seconds_worst = log10_keyspace - log10(guesses_per_second)

  return { log10_seconds_avg, log10_seconds_worst, log10_keyspace }
```

### Converting log10(seconds) to a friendly duration

```pseudo
UNITS = [
  { name: "seconds", seconds_per_unit: 1 },
  { name: "minutes", seconds_per_unit: 60 },
  { name: "hours",   seconds_per_unit: 3600 },
  { name: "days",    seconds_per_unit: 86400 },
  { name: "years",   seconds_per_unit: 31557600 }  // 365.25 days
]

function format_duration_from_log10(log10_seconds):
  // Choose the largest unit that keeps the value >= 1
  best_unit = "seconds"
  for unit in UNITS:
    log10_value_in_unit = log10_seconds - log10(unit.seconds_per_unit)
    if log10_value_in_unit >= 0:
      best_unit = unit

  log10_value = log10_seconds - log10(best_unit.seconds_per_unit)

  // If extremely large, show scientific notation (e.g., 1.7e11 years)
  if log10_value >= 6:
    mantissa = 10^(log10_value - floor(log10_value))
    exponent = floor(log10_value)
    return sprintf("%.2f×10^%d %s", mantissa, exponent, best_unit.name)

  // Otherwise show a normal rounded number
  value = 10^log10_value
  return sprintf("%.2f %s", value, best_unit.name)
```

### Putting it together (UI handler)

```pseudo
function on_password_input(pw, preset_key = DEFAULT_PRESET_KEY):
  preset = ATTACK_PRESETS[preset_key]

  analysis = analyze_password(pw)
  if not analysis.valid:
    render_error("Enter a non-empty password.")
    return

  logs = estimate_crack_time_log10(analysis.L, analysis.A, preset.guesses_per_second)

  avg_str   = format_duration_from_log10(logs.log10_seconds_avg)
  worst_str = format_duration_from_log10(logs.log10_seconds_worst)

  render({
    length: analysis.L,
    charset_size: analysis.A,
    categories: {
      lower: analysis.has_lower,
      upper: analysis.has_upper,
      digit: analysis.has_digit,
      symbol: analysis.has_symbol
    },
    assumptions: preset.label,
    avg_time: avg_str,
    worst_time: worst_str,
    explainer: "Brute force tries every combination. Each extra character multiplies the search space by A."
  })

  render_warning("This assumes a random password. Dictionary words/patterns can crack much faster.")
  render_privacy_note("Don’t enter a real password; this runs locally and is not stored.")
```

---

## The “best assumptions” I’d ship as defaults (so it teaches well)

If you force me to pick **one** default, I’d pick:

**Offline brute force, fast-hash, 1× high-end consumer GPU**
Because it dramatizes the lesson quickly (short passwords become “instant”) and matches what most learners *think* “brute force” means. Then add an “Advanced: bcrypt / slower hashing” toggle so you can teach the nuance that password storage defenses matter too. The Hive Systems writeup explicitly emphasizes that table outputs depend on hashing + hardware assumptions, and that “black box” brute force is a worst-case framing. ([Hive Systems][2])

---

## One candid note about your example numbers

Your three bullet examples can’t all come from one consistent guesses/sec assumption (the implied rates differ by orders of magnitude). If you want, I can help you **revise the three bullets** so they match whichever default preset you choose, while keeping the same rhetorical impact.

**Confidence:** High on the modeling approach, math, and the log-space implementation design. Medium on any single “typical hacker guesses/sec” value because it varies drastically with hash algorithm/work factor and attacker resources—hence the recommendation to use presets grounded in published benchmark culture.

[1]: https://www.verizon.com/business/resources/reports/2024-dbir-data-breach-investigations-report.pdf "2024 Data Breach Investigations Report | Verizon"
[2]: https://www.hivesystems.com/blog/are-your-passwords-in-the-green "The 2025 Hive Systems Password Table Is Here - Passwords Are Easier to Crack Than Ever"
[3]: https://www.tomshardware.com/news/rtx-4090-password-cracking-comparison "One RTX 4090 Is Faster at Password Cracking Than Three 6900XTs, Eight 1080s | Tom's Hardware"
[4]: https://hashcat.net/forum/thread-12530.html "Best Hardware for bcrypt"
